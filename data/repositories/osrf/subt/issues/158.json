{"priority": "major", "kind": "bug", "repository": {"links": {"self": {"href": "data/repositories/osrf/subt.json"}, "html": {"href": "#!/osrf/subt"}, "avatar": {"href": "data/bytebucket.org/ravatar/{3c95f6ad-c304-407c-b838-09597d836552}ts=2272898"}}, "type": "repository", "name": "subt", "full_name": "osrf/subt", "uuid": "{3c95f6ad-c304-407c-b838-09597d836552}"}, "links": {"attachments": {"href": "data/repositories/osrf/subt/issues/158/attachments_page=1.json"}, "self": {"href": "data/repositories/osrf/subt/issues/158.json"}, "watch": {"href": "https://api.bitbucket.org/2.0/repositories/osrf/subt/issues/158/watch"}, "comments": {"href": "data/repositories/osrf/subt/issues/158/comments_page=1.json"}, "html": {"href": "#!/osrf/subt/issues/158/tf-transformlistener-lookups-always"}, "vote": {"href": "https://api.bitbucket.org/2.0/repositories/osrf/subt/issues/158/vote"}}, "reporter": {"display_name": "Reid Sawtell", "uuid": "{845ed98c-79aa-4771-ab0d-6d8424f27344}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B845ed98c-79aa-4771-ab0d-6d8424f27344%7D"}, "html": {"href": "https://bitbucket.org/%7B845ed98c-79aa-4771-ab0d-6d8424f27344%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/8a592422a10cc54f020efbc4d867c556d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsRS-6.png"}}, "nickname": "rsawtell", "type": "user", "account_id": "557058:ba6a5dd6-99be-45af-a802-687b3318965a"}, "title": "tf::TransformListener() lookups always returning most recent tranform", "component": null, "votes": 0, "watches": 1, "content": {"raw": "We are having a problem where our calls to lookupTransform are always returning the most recent transform, even when we specify a time in the past. The exact same code works as expected in Gazebo.\r\n\r\nTo figure out what was going on I output the transform offsets before and after a delay, with the lookup targeting the same original timestamp in both instances. Data \u201cA\u201d is the first call, and data \u201cB\u201d is after the delay has passed.\r\n\r\n![](data/bitbucket.org/repo/8ze6Mjd/images/324484230-image.png)\r\n\u201cA\u201d and \u201cB\u201d in the above graph use the targeted transform timestamp as the X-axis, while \u201cB-ros\u201d substitutes the current ROS time for the X-axis. As expected, \u201cA\u201d and \u201cB\u201d are identical while \u201cB-ros\u201d is shifted right by the delay of 4.5 seconds I used.\r\n\r\nThe same code in Ignition performs differently however:\r\n\r\n![](data/bitbucket.org/repo/8ze6Mjd/images/3467047115-image.png)\r\nHere the \u201cA\u201d and \u201cB-ros\u201d data are aligned: the returned transform for \u201cB\u201d is for the current time in ros, rather than the historic transform data.\r\n\r\n\u200c\r\n\r\nFor reference, we are initializing  a listener when our node is constructed:\r\n\r\n```\r\nlistener = new tf::TransformListener();\r\n```\r\n\r\nAnd when we do the lookup later:\r\n\r\n```\r\ntf::StampedTransform transform;\r\n\r\nif(!listener->waitForTransform(target_frame,cloud_msg->header.frame_id,cloud_msg->header.stamp,ros::Duration(3.0)))\r\n{\r\n    printf(\"Failed to acquire transform!\\n\");\r\n    return;\r\n}\r\n\r\nlistener->lookupTransform(target_frame,cloud_msg->header.frame_id,cloud_msg->header.stamp,transform);\r\n```\r\n\r\nwhere cloud\\_msg is of type \u201cconst sensor\\_msgs::PointCloud2ConstPtr& cloud\\_msg\u201d \\(It\u2019s a subscription to the LIDAR points topic\\)", "markup": "markdown", "html": "<p>We are having a problem where our calls to lookupTransform are always returning the most recent transform, even when we specify a time in the past. The exact same code works as expected in Gazebo.</p>\n<p>To figure out what was going on I output the transform offsets before and after a delay, with the lookup targeting the same original timestamp in both instances. Data \u201cA\u201d is the first call, and data \u201cB\u201d is after the delay has passed.</p>\n<p><img alt=\"\" src=\"data/bitbucket.org/repo/8ze6Mjd/images/324484230-image.png\" />\n\u201cA\u201d and \u201cB\u201d in the above graph use the targeted transform timestamp as the X-axis, while \u201cB-ros\u201d substitutes the current ROS time for the X-axis. As expected, \u201cA\u201d and \u201cB\u201d are identical while \u201cB-ros\u201d is shifted right by the delay of 4.5 seconds I used.</p>\n<p>The same code in Ignition performs differently however:</p>\n<p><img alt=\"\" src=\"data/bitbucket.org/repo/8ze6Mjd/images/3467047115-image.png\" />\nHere the \u201cA\u201d and \u201cB-ros\u201d data are aligned: the returned transform for \u201cB\u201d is for the current time in ros, rather than the historic transform data.</p>\n<p>\u200c</p>\n<p>For reference, we are initializing  a listener when our node is constructed:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"nt\">listener</span> <span class=\"o\">=</span> <span class=\"nt\">new</span> <span class=\"nt\">tf</span><span class=\"p\">::</span><span class=\"nd\">TransformListener</span><span class=\"o\">();</span>\n</pre></div>\n\n\n<p>And when we do the lookup later:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"nt\">tf</span><span class=\"p\">::</span><span class=\"nd\">StampedTransform</span> <span class=\"nt\">transform</span><span class=\"o\">;</span>\n\n<span class=\"nt\">if</span><span class=\"o\">(!</span><span class=\"nt\">listener-</span><span class=\"o\">&gt;</span><span class=\"nt\">waitForTransform</span><span class=\"o\">(</span><span class=\"nt\">target_frame</span><span class=\"o\">,</span><span class=\"nt\">cloud_msg-</span><span class=\"o\">&gt;</span><span class=\"nt\">header</span><span class=\"p\">.</span><span class=\"nc\">frame_id</span><span class=\"o\">,</span><span class=\"nt\">cloud_msg-</span><span class=\"o\">&gt;</span><span class=\"nt\">header</span><span class=\"p\">.</span><span class=\"nc\">stamp</span><span class=\"o\">,</span><span class=\"nt\">ros</span><span class=\"p\">::</span><span class=\"nd\">Duration</span><span class=\"o\">(</span><span class=\"nt\">3</span><span class=\"p\">.</span><span class=\"nc\">0</span><span class=\"o\">)))</span>\n<span class=\"p\">{</span>\n    <span class=\"err\">printf(&quot;Failed</span> <span class=\"err\">to</span> <span class=\"err\">acquire</span> <span class=\"err\">transform!\\n&quot;)</span><span class=\"p\">;</span>\n    <span class=\"err\">return</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n\n<span class=\"nt\">listener-</span><span class=\"o\">&gt;</span><span class=\"nt\">lookupTransform</span><span class=\"o\">(</span><span class=\"nt\">target_frame</span><span class=\"o\">,</span><span class=\"nt\">cloud_msg-</span><span class=\"o\">&gt;</span><span class=\"nt\">header</span><span class=\"p\">.</span><span class=\"nc\">frame_id</span><span class=\"o\">,</span><span class=\"nt\">cloud_msg-</span><span class=\"o\">&gt;</span><span class=\"nt\">header</span><span class=\"p\">.</span><span class=\"nc\">stamp</span><span class=\"o\">,</span><span class=\"nt\">transform</span><span class=\"o\">);</span>\n</pre></div>\n\n\n<p>where cloud_msg is of type \u201cconst sensor_msgs::PointCloud2ConstPtr&amp; cloud_msg\u201d (It\u2019s a subscription to the LIDAR points topic)</p>", "type": "rendered"}, "assignee": null, "state": "closed", "version": null, "edited_on": null, "created_on": "2019-08-13T21:05:16.643679+00:00", "milestone": null, "updated_on": "2019-08-14T17:48:15.259870+00:00", "type": "issue", "id": 158}