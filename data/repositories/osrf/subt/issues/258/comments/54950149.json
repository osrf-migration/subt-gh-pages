{"links": {"self": {"href": "data/repositories/osrf/subt/issues/258/comments/54950149.json"}, "html": {"href": "#!/osrf/subt/issues/258#comment-54950149"}}, "issue": {"links": {"self": {"href": "data/repositories/osrf/subt/issues/258.json"}}, "type": "issue", "id": 258, "repository": {"links": {"self": {"href": "data/repositories/osrf/subt.json"}, "html": {"href": "#!/osrf/subt"}, "avatar": {"href": "data/bytebucket.org/ravatar/{3c95f6ad-c304-407c-b838-09597d836552}ts=2272898"}}, "type": "repository", "name": "subt", "full_name": "osrf/subt", "uuid": "{3c95f6ad-c304-407c-b838-09597d836552}"}, "title": "Virtual Tunnel Circuit Finals Videos"}, "content": {"raw": "@{5b5b1c941394ae6a72c021df} Our system is somewhat similar to ROS but with a key difference - each published message has an unique timestamp and this timestamp provides total ordering on the messages in the system. Further each node is guaranteed to receive all incoming messages ordered by this timestamp. Then the whole stream of messages in the system is logged to a file.\n\nThe key differences wrt ROS are:\n\n* our system is for a single computer where all nodes have access to a shared clock\n* each node has one incoming queue for all messages it is subscribed to - in ROS there is one TCP connection per subscription so the delivery order is not guaranteed \\(message1 sent later than message2 can be received in arbitrary order\\) - in ROS this uncertainty precludes exact replay\n* the nodes interact with the outside world only through the message stream \\(there are so called \u201cborder nodes\u201d that cannot be currently replayed - those are responsible for example for reading from a file descriptor and publishing the results as a message in the system - those tend to be very very simple\\)\n\nThis system gives us exact node replay - meaning that if we have our log we can deterministicaly recreate any state the controller was in. This capability somewhat is similar to [https://rr-project.org/](https://rr-project.org/) but it is done from application level only and is currently implemented only for our python system. The same system is used for both - virtual and system track.\n\nWhen replaying, you can imagine anything is available \\(step through code, add prints, generate graphs, maps etc.\\).", "markup": "markdown", "html": "<p><span class=\"ap-mention\" data-atlassian-id=\"5b5b1c941394ae6a72c021df\">@Hector Escobar</span> Our system is somewhat similar to ROS but with a key difference - each published message has an unique timestamp and this timestamp provides total ordering on the messages in the system. Further each node is guaranteed to receive all incoming messages ordered by this timestamp. Then the whole stream of messages in the system is logged to a file.</p>\n<p>The key differences wrt ROS are:</p>\n<ul>\n<li>our system is for a single computer where all nodes have access to a shared clock</li>\n<li>each node has one incoming queue for all messages it is subscribed to - in ROS there is one TCP connection per subscription so the delivery order is not guaranteed (message1 sent later than message2 can be received in arbitrary order) - in ROS this uncertainty precludes exact replay</li>\n<li>the nodes interact with the outside world only through the message stream (there are so called \u201cborder nodes\u201d that cannot be currently replayed - those are responsible for example for reading from a file descriptor and publishing the results as a message in the system - those tend to be very very simple)</li>\n</ul>\n<p>This system gives us exact node replay - meaning that if we have our log we can deterministicaly recreate any state the controller was in. This capability somewhat is similar to <a data-is-external-link=\"true\" href=\"https://rr-project.org/\" rel=\"nofollow\">https://rr-project.org/</a> but it is done from application level only and is currently implemented only for our python system. The same system is used for both - virtual and system track.</p>\n<p>When replaying, you can imagine anything is available (step through code, add prints, generate graphs, maps etc.).</p>", "type": "rendered"}, "created_on": "2019-11-25T13:30:32.301587+00:00", "user": {"display_name": "Zbyn\u011bk Winkler", "uuid": "{d253a02a-aa23-4c28-9bf2-75863acb0ee0}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bd253a02a-aa23-4c28-9bf2-75863acb0ee0%7D"}, "html": {"href": "https://bitbucket.org/%7Bd253a02a-aa23-4c28-9bf2-75863acb0ee0%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/326a12c819c60ee18418b5d01000d03fd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsZW-1.png"}}, "nickname": "Zbyn\u011bk Winkler (robotika)", "type": "user", "account_id": "557058:a92b5a4f-5b91-4853-8dec-b918bd975e70"}, "updated_on": null, "type": "issue_comment", "id": 54950149}