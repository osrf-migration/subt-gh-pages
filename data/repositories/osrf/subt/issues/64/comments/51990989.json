{"links": {"self": {"href": "data/repositories/osrf/subt/issues/64/comments/51990989.json"}, "html": {"href": "#!/osrf/subt/issues/64#comment-51990989"}}, "issue": {"links": {"self": {"href": "data/repositories/osrf/subt/issues/64.json"}}, "type": "issue", "id": 64, "repository": {"links": {"self": {"href": "data/repositories/osrf/subt.json"}, "html": {"href": "#!/osrf/subt"}, "avatar": {"href": "data/bytebucket.org/ravatar/{3c95f6ad-c304-407c-b838-09597d836552}ts=2272898"}}, "type": "repository", "name": "subt", "full_name": "osrf/subt", "uuid": "{3c95f6ad-c304-407c-b838-09597d836552}"}, "title": "CommsClient->Neighbors() always empty"}, "content": {"raw": "I opened pull request #128 which \\(I believe\\) addresses this issue as well as issue #54.\n\n\u200c\n\nThe received signal strength is computed from whatever path loss model is being used and is now passed up to the CommsClient with every successful packet and stored in the Neighbor\\_M which can be retrieved by the `Neighbors()` function call. Note this is a slight API change as the `Neighbors()` function now returns a `std::map` indexed by the neighbor addresses and each element stores a `std::pair` of `ros::Time` and a `double` indicating the received signal strength in dBm.\n\n\u200c\n\nI've also implemented \\(for \\(1\\) above\\), the ability to run, e.g. `client->StartBeaconInterval(ros::Duration(1.0))` \\(see subt\\_example\\_node.cc::265\\) which will generate beacon packets that are broadcast at the desired rate - this will populate the Neighbors data \\(when communication is successful without the need to manually send data over the channel otherwise \\(though this will work as well!\\)", "markup": "markdown", "html": "<p>I opened <a href=\"#!/osrf/subt/pull-requests/128/update-the-neighbor-reporting-interface\" rel=\"nofollow\" class=\"ap-connect-link\">pull request #128</a> which (I believe) addresses this issue as well as issue <a href=\"#!/osrf/subt/issues/54/can-we-move-the-placement-of-sensors-on\" rel=\"nofollow\" title=\"Can we move the placement of sensors on the vehicles\" class=\"ap-connect-link\"><s>#54</s></a>.</p>\n<p>\u200c</p>\n<p>The received signal strength is computed from whatever path loss model is being used and is now passed up to the CommsClient with every successful packet and stored in the Neighbor_M which can be retrieved by the <code>Neighbors()</code> function call. Note this is a slight API change as the <code>Neighbors()</code> function now returns a <code>std::map</code> indexed by the neighbor addresses and each element stores a <code>std::pair</code> of <code>ros::Time</code> and a <code>double</code> indicating the received signal strength in dBm.</p>\n<p>\u200c</p>\n<p>I've also implemented (for (1) above), the ability to run, e.g. <code>client-&gt;StartBeaconInterval(ros::Duration(1.0))</code> (see subt_example_node.cc::265) which will generate beacon packets that are broadcast at the desired rate - this will populate the Neighbors data (when communication is successful without the need to manually send data over the channel otherwise (though this will work as well!)</p>", "type": "rendered"}, "created_on": "2019-05-06T01:22:14.541267+00:00", "user": {"display_name": "Jon Fink", "uuid": "{89cf7350-7d3a-4a2e-a6ce-43d49bfe9001}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B89cf7350-7d3a-4a2e-a6ce-43d49bfe9001%7D"}, "html": {"href": "https://bitbucket.org/%7B89cf7350-7d3a-4a2e-a6ce-43d49bfe9001%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/d3f96b67926116d5c1121e7dc9a1a8f2d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsJF-5.png"}}, "nickname": "jonfink-arl", "type": "user", "account_id": "5b90221dfa38ae2c89609691"}, "updated_on": null, "type": "issue_comment", "id": 51990989}