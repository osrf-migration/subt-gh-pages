{"rendered": {"description": {"raw": "**Motivation**: Before this pull request, one of the parameters of the communication model is distance between source and destination. For SubT, distance is not very appropriate because source and destination could be very close but with a thick wall in between. Similarly, source and destination could be far but within line of sight across a straight section of a tunnel. This pull request introduces a new replacement for distance: connectivity cost.\r\n\r\n**Changes to world files**: After this pull request, a SubT world requires three different files:\r\n\r\n* <SCENARIO>.world: The regular Gazebo world file. Nothing changes here.\r\n* <SCENARIO>.dot: This text file captures the topological map of the scenario. Each section of the scenario \\(e.g.: a tunnel tile, the staging area\\) is a vertex of a graph and all pairs of sections physically connected in the world are connected with an edge in the graph. Additionally, vertices capture the model type and model name in case is relevant for the future.\r\n* <SCENARIO>.dat: This binary file is a look-up-table used by the communication model. The content of this file is a sequence of tuples with the format `<int32_t, int32_t, int32_t, uint64_t>`. The first three elements represent a 3D point and the last element is the Id of the vertex associated to the model that surrounds the previous point.\r\n\r\n**Changes to the communication model:** After this pull request, the communication model loads the `.dat` and `.dot` files associated to the current Gazebo world. The `.dot` file is used to create an in-memory graph. We run `Dijkstra` on this graph to get the cost of traversing any pair of vertices. The `.dat` file is used to convert a 3D point to the vertex Id where the point is located. This will be relevant when we have two robots located in two 3D coordinates of the world. We need to know which vertices correspond to those two points. When we have the two vertex Ids, we can use the information that we got after running `Dijkstra` to get the associated cost of the path connecting the two robots. The SubT message is discarded if the cost is higher than a given threshold. This threshold is a new parameter of the communication model named `comms_cost_max`.\r\n\r\n**How are the costs being assigned to each edge in the graph?** Manually and based on the next heuristic:\r\n\r\n* Straight section <-> straight section:`1`\r\n* Straight section <-> non-straight section:`3`\r\n* Non-straight section <-> non-straight section:`6`\r\n\r\n**How do I \\[re\\]generate a** `.dat` **file?** Let's use an example for generating `tunnel_practice_1.dat`:\r\n\r\n    roslaunch subt_gazebo visibility.launch scenario:=tunnel_practice_1\r\n\r\nYou don't need to do this step unless you create a custom world file or modify an existing one because we are committing the `.dat` files.\r\n\r\n**Why are we committing the .dat \\(binary\\) files into the repository?** We considered a couple of options, here\u2019s one:\r\n\r\n* Launch the visibility.launch file when running the regular quickstart.launch . This was a promising idea but launch files are not enough to implement the logic that we want. We want to launch the visibility.launch first, and then, when the `.dat` file has been generated launch the quickstart.launch . We might use scripts instead, but given the different set of launch files that we have, it will complicate things unnecessary. The solution of checking in these `.dat` files is very simple \\(although I agree that not super elegant\\).\r\n\r\n**Developer bonus:** I wouldn\u2019t officially advertise it but there\u2019s a service available \\(only if you\u2019re in the same machine as Gazebo\\)  to display all the areas of the world that are visible from the perspective of one robot. It uses Gazebo markers but it slows down gzclient a lot given the amount of markers published. You can type the following command from the console:\r\n\r\n    ign service -s /subt/comms_model/visualize --reqtype ignition.msgs.StringMsg --reptype ignition.msgs.Boolean  --timeout 60000 --req 'data: \"X1\"'\r\n\r\nFeel free to replace `X1` with the name of the robot you want to check.", "markup": "markdown", "html": "<p><strong>Motivation</strong>: Before this pull request, one of the parameters of the communication model is distance between source and destination. For SubT, distance is not very appropriate because source and destination could be very close but with a thick wall in between. Similarly, source and destination could be far but within line of sight across a straight section of a tunnel. This pull request introduces a new replacement for distance: connectivity cost.</p>\n<p><strong>Changes to world files</strong>: After this pull request, a SubT world requires three different files:</p>\n<ul>\n<li>&lt;SCENARIO&gt;.world: The regular Gazebo world file. Nothing changes here.</li>\n<li>&lt;SCENARIO&gt;.dot: This text file captures the topological map of the scenario. Each section of the scenario (e.g.: a tunnel tile, the staging area) is a vertex of a graph and all pairs of sections physically connected in the world are connected with an edge in the graph. Additionally, vertices capture the model type and model name in case is relevant for the future.</li>\n<li>&lt;SCENARIO&gt;.dat: This binary file is a look-up-table used by the communication model. The content of this file is a sequence of tuples with the format <code>&lt;int32_t, int32_t, int32_t, uint64_t&gt;</code>. The first three elements represent a 3D point and the last element is the Id of the vertex associated to the model that surrounds the previous point.</li>\n</ul>\n<p><strong>Changes to the communication model:</strong> After this pull request, the communication model loads the <code>.dat</code> and <code>.dot</code> files associated to the current Gazebo world. The <code>.dot</code> file is used to create an in-memory graph. We run <code>Dijkstra</code> on this graph to get the cost of traversing any pair of vertices. The <code>.dat</code> file is used to convert a 3D point to the vertex Id where the point is located. This will be relevant when we have two robots located in two 3D coordinates of the world. We need to know which vertices correspond to those two points. When we have the two vertex Ids, we can use the information that we got after running <code>Dijkstra</code> to get the associated cost of the path connecting the two robots. The SubT message is discarded if the cost is higher than a given threshold. This threshold is a new parameter of the communication model named <code>comms_cost_max</code>.</p>\n<p><strong>How are the costs being assigned to each edge in the graph?</strong> Manually and based on the next heuristic:</p>\n<ul>\n<li>Straight section &lt;-&gt; straight section:<code>1</code></li>\n<li>Straight section &lt;-&gt; non-straight section:<code>3</code></li>\n<li>Non-straight section &lt;-&gt; non-straight section:<code>6</code></li>\n</ul>\n<p><strong>How do I [re]generate a</strong> <code>.dat</code> <strong>file?</strong> Let's use an example for generating <code>tunnel_practice_1.dat</code>:</p>\n<div class=\"codehilite\"><pre><span></span>roslaunch subt_gazebo visibility.launch scenario:=tunnel_practice_1\n</pre></div>\n\n\n<p>You don't need to do this step unless you create a custom world file or modify an existing one because we are committing the <code>.dat</code> files.</p>\n<p><strong>Why are we committing the .dat (binary) files into the repository?</strong> We considered a couple of options, here\u2019s one:</p>\n<ul>\n<li>Launch the visibility.launch file when running the regular quickstart.launch . This was a promising idea but launch files are not enough to implement the logic that we want. We want to launch the visibility.launch first, and then, when the <code>.dat</code> file has been generated launch the quickstart.launch . We might use scripts instead, but given the different set of launch files that we have, it will complicate things unnecessary. The solution of checking in these <code>.dat</code> files is very simple (although I agree that not super elegant).</li>\n</ul>\n<p><strong>Developer bonus:</strong> I wouldn\u2019t officially advertise it but there\u2019s a service available (only if you\u2019re in the same machine as Gazebo)  to display all the areas of the world that are visible from the perspective of one robot. It uses Gazebo markers but it slows down gzclient a lot given the amount of markers published. You can type the following command from the console:</p>\n<div class=\"codehilite\"><pre><span></span>ign service -s /subt/comms_model/visualize --reqtype ignition.msgs.StringMsg --reptype ignition.msgs.Boolean  --timeout 60000 --req &#39;data: &quot;X1&quot;&#39;\n</pre></div>\n\n\n<p>Feel free to replace <code>X1</code> with the name of the robot you want to check.</p>", "type": "rendered"}, "title": {"raw": "Communication model based on graph cost", "markup": "markdown", "html": "<p>Communication model based on graph cost</p>", "type": "rendered"}}, "type": "pullrequest", "description": "**Motivation**: Before this pull request, one of the parameters of the communication model is distance between source and destination. For SubT, distance is not very appropriate because source and destination could be very close but with a thick wall in between. Similarly, source and destination could be far but within line of sight across a straight section of a tunnel. This pull request introduces a new replacement for distance: connectivity cost.\r\n\r\n**Changes to world files**: After this pull request, a SubT world requires three different files:\r\n\r\n* <SCENARIO>.world: The regular Gazebo world file. Nothing changes here.\r\n* <SCENARIO>.dot: This text file captures the topological map of the scenario. Each section of the scenario \\(e.g.: a tunnel tile, the staging area\\) is a vertex of a graph and all pairs of sections physically connected in the world are connected with an edge in the graph. Additionally, vertices capture the model type and model name in case is relevant for the future.\r\n* <SCENARIO>.dat: This binary file is a look-up-table used by the communication model. The content of this file is a sequence of tuples with the format `<int32_t, int32_t, int32_t, uint64_t>`. The first three elements represent a 3D point and the last element is the Id of the vertex associated to the model that surrounds the previous point.\r\n\r\n**Changes to the communication model:** After this pull request, the communication model loads the `.dat` and `.dot` files associated to the current Gazebo world. The `.dot` file is used to create an in-memory graph. We run `Dijkstra` on this graph to get the cost of traversing any pair of vertices. The `.dat` file is used to convert a 3D point to the vertex Id where the point is located. This will be relevant when we have two robots located in two 3D coordinates of the world. We need to know which vertices correspond to those two points. When we have the two vertex Ids, we can use the information that we got after running `Dijkstra` to get the associated cost of the path connecting the two robots. The SubT message is discarded if the cost is higher than a given threshold. This threshold is a new parameter of the communication model named `comms_cost_max`.\r\n\r\n**How are the costs being assigned to each edge in the graph?** Manually and based on the next heuristic:\r\n\r\n* Straight section <-> straight section:`1`\r\n* Straight section <-> non-straight section:`3`\r\n* Non-straight section <-> non-straight section:`6`\r\n\r\n**How do I \\[re\\]generate a** `.dat` **file?** Let's use an example for generating `tunnel_practice_1.dat`:\r\n\r\n    roslaunch subt_gazebo visibility.launch scenario:=tunnel_practice_1\r\n\r\nYou don't need to do this step unless you create a custom world file or modify an existing one because we are committing the `.dat` files.\r\n\r\n**Why are we committing the .dat \\(binary\\) files into the repository?** We considered a couple of options, here\u2019s one:\r\n\r\n* Launch the visibility.launch file when running the regular quickstart.launch . This was a promising idea but launch files are not enough to implement the logic that we want. We want to launch the visibility.launch first, and then, when the `.dat` file has been generated launch the quickstart.launch . We might use scripts instead, but given the different set of launch files that we have, it will complicate things unnecessary. The solution of checking in these `.dat` files is very simple \\(although I agree that not super elegant\\).\r\n\r\n**Developer bonus:** I wouldn\u2019t officially advertise it but there\u2019s a service available \\(only if you\u2019re in the same machine as Gazebo\\)  to display all the areas of the world that are visible from the perspective of one robot. It uses Gazebo markers but it slows down gzclient a lot given the amount of markers published. You can type the following command from the console:\r\n\r\n    ign service -s /subt/comms_model/visualize --reqtype ignition.msgs.StringMsg --reptype ignition.msgs.Boolean  --timeout 60000 --req 'data: \"X1\"'\r\n\r\nFeel free to replace `X1` with the name of the robot you want to check.", "links": {"decline": {"href": "https://api.bitbucket.org/2.0/repositories/osrf/subt/pullrequests/95/decline"}, "diffstat": {"href": "https://api.bitbucket.org/2.0/repositories/osrf/subt/diffstat/osrf/subt:ac1b9bbbc424%0Da53fb3eb6a81?from_pullrequest_id=95"}, "commits": {"href": "data/repositories/osrf/subt/pullrequests/95/commits.json"}, "self": {"href": "data/repositories/osrf/subt/pullrequests/95.json"}, "comments": {"href": "data/repositories/osrf/subt/pullrequests/95/comments_page=1.json"}, "merge": {"href": "https://api.bitbucket.org/2.0/repositories/osrf/subt/pullrequests/95/merge"}, "html": {"href": "#!/osrf/subt/pull-requests/95"}, "activity": {"href": "data/repositories/osrf/subt/pullrequests/95/activity.json"}, "diff": {"href": "https://api.bitbucket.org/2.0/repositories/osrf/subt/diff/osrf/subt:ac1b9bbbc424%0Da53fb3eb6a81?from_pullrequest_id=95"}, "approve": {"href": "https://api.bitbucket.org/2.0/repositories/osrf/subt/pullrequests/95/approve"}, "statuses": {"href": "data/repositories/osrf/subt/pullrequests/95/statuses_page=1.json"}}, "title": "Communication model based on graph cost", "close_source_branch": true, "reviewers": [], "id": 95, "destination": {"commit": {"hash": "a53fb3eb6a81", "type": "commit", "links": {"self": {"href": "data/repositories/osrf/subt/commit/a53fb3eb6a81.json"}, "html": {"href": "#!/osrf/subt/commits/a53fb3eb6a81"}}}, "repository": {"links": {"self": {"href": "data/repositories/osrf/subt.json"}, "html": {"href": "#!/osrf/subt"}, "avatar": {"href": "data/bytebucket.org/ravatar/{3c95f6ad-c304-407c-b838-09597d836552}ts=2272898"}}, "type": "repository", "name": "subt", "full_name": "osrf/subt", "uuid": "{3c95f6ad-c304-407c-b838-09597d836552}"}, "branch": {"name": "default"}}, "created_on": "2018-12-01T00:15:30.753435+00:00", "summary": {"raw": "**Motivation**: Before this pull request, one of the parameters of the communication model is distance between source and destination. For SubT, distance is not very appropriate because source and destination could be very close but with a thick wall in between. Similarly, source and destination could be far but within line of sight across a straight section of a tunnel. This pull request introduces a new replacement for distance: connectivity cost.\r\n\r\n**Changes to world files**: After this pull request, a SubT world requires three different files:\r\n\r\n* <SCENARIO>.world: The regular Gazebo world file. Nothing changes here.\r\n* <SCENARIO>.dot: This text file captures the topological map of the scenario. Each section of the scenario \\(e.g.: a tunnel tile, the staging area\\) is a vertex of a graph and all pairs of sections physically connected in the world are connected with an edge in the graph. Additionally, vertices capture the model type and model name in case is relevant for the future.\r\n* <SCENARIO>.dat: This binary file is a look-up-table used by the communication model. The content of this file is a sequence of tuples with the format `<int32_t, int32_t, int32_t, uint64_t>`. The first three elements represent a 3D point and the last element is the Id of the vertex associated to the model that surrounds the previous point.\r\n\r\n**Changes to the communication model:** After this pull request, the communication model loads the `.dat` and `.dot` files associated to the current Gazebo world. The `.dot` file is used to create an in-memory graph. We run `Dijkstra` on this graph to get the cost of traversing any pair of vertices. The `.dat` file is used to convert a 3D point to the vertex Id where the point is located. This will be relevant when we have two robots located in two 3D coordinates of the world. We need to know which vertices correspond to those two points. When we have the two vertex Ids, we can use the information that we got after running `Dijkstra` to get the associated cost of the path connecting the two robots. The SubT message is discarded if the cost is higher than a given threshold. This threshold is a new parameter of the communication model named `comms_cost_max`.\r\n\r\n**How are the costs being assigned to each edge in the graph?** Manually and based on the next heuristic:\r\n\r\n* Straight section <-> straight section:`1`\r\n* Straight section <-> non-straight section:`3`\r\n* Non-straight section <-> non-straight section:`6`\r\n\r\n**How do I \\[re\\]generate a** `.dat` **file?** Let's use an example for generating `tunnel_practice_1.dat`:\r\n\r\n    roslaunch subt_gazebo visibility.launch scenario:=tunnel_practice_1\r\n\r\nYou don't need to do this step unless you create a custom world file or modify an existing one because we are committing the `.dat` files.\r\n\r\n**Why are we committing the .dat \\(binary\\) files into the repository?** We considered a couple of options, here\u2019s one:\r\n\r\n* Launch the visibility.launch file when running the regular quickstart.launch . This was a promising idea but launch files are not enough to implement the logic that we want. We want to launch the visibility.launch first, and then, when the `.dat` file has been generated launch the quickstart.launch . We might use scripts instead, but given the different set of launch files that we have, it will complicate things unnecessary. The solution of checking in these `.dat` files is very simple \\(although I agree that not super elegant\\).\r\n\r\n**Developer bonus:** I wouldn\u2019t officially advertise it but there\u2019s a service available \\(only if you\u2019re in the same machine as Gazebo\\)  to display all the areas of the world that are visible from the perspective of one robot. It uses Gazebo markers but it slows down gzclient a lot given the amount of markers published. You can type the following command from the console:\r\n\r\n    ign service -s /subt/comms_model/visualize --reqtype ignition.msgs.StringMsg --reptype ignition.msgs.Boolean  --timeout 60000 --req 'data: \"X1\"'\r\n\r\nFeel free to replace `X1` with the name of the robot you want to check.", "markup": "markdown", "html": "<p><strong>Motivation</strong>: Before this pull request, one of the parameters of the communication model is distance between source and destination. For SubT, distance is not very appropriate because source and destination could be very close but with a thick wall in between. Similarly, source and destination could be far but within line of sight across a straight section of a tunnel. This pull request introduces a new replacement for distance: connectivity cost.</p>\n<p><strong>Changes to world files</strong>: After this pull request, a SubT world requires three different files:</p>\n<ul>\n<li>&lt;SCENARIO&gt;.world: The regular Gazebo world file. Nothing changes here.</li>\n<li>&lt;SCENARIO&gt;.dot: This text file captures the topological map of the scenario. Each section of the scenario (e.g.: a tunnel tile, the staging area) is a vertex of a graph and all pairs of sections physically connected in the world are connected with an edge in the graph. Additionally, vertices capture the model type and model name in case is relevant for the future.</li>\n<li>&lt;SCENARIO&gt;.dat: This binary file is a look-up-table used by the communication model. The content of this file is a sequence of tuples with the format <code>&lt;int32_t, int32_t, int32_t, uint64_t&gt;</code>. The first three elements represent a 3D point and the last element is the Id of the vertex associated to the model that surrounds the previous point.</li>\n</ul>\n<p><strong>Changes to the communication model:</strong> After this pull request, the communication model loads the <code>.dat</code> and <code>.dot</code> files associated to the current Gazebo world. The <code>.dot</code> file is used to create an in-memory graph. We run <code>Dijkstra</code> on this graph to get the cost of traversing any pair of vertices. The <code>.dat</code> file is used to convert a 3D point to the vertex Id where the point is located. This will be relevant when we have two robots located in two 3D coordinates of the world. We need to know which vertices correspond to those two points. When we have the two vertex Ids, we can use the information that we got after running <code>Dijkstra</code> to get the associated cost of the path connecting the two robots. The SubT message is discarded if the cost is higher than a given threshold. This threshold is a new parameter of the communication model named <code>comms_cost_max</code>.</p>\n<p><strong>How are the costs being assigned to each edge in the graph?</strong> Manually and based on the next heuristic:</p>\n<ul>\n<li>Straight section &lt;-&gt; straight section:<code>1</code></li>\n<li>Straight section &lt;-&gt; non-straight section:<code>3</code></li>\n<li>Non-straight section &lt;-&gt; non-straight section:<code>6</code></li>\n</ul>\n<p><strong>How do I [re]generate a</strong> <code>.dat</code> <strong>file?</strong> Let's use an example for generating <code>tunnel_practice_1.dat</code>:</p>\n<div class=\"codehilite\"><pre><span></span>roslaunch subt_gazebo visibility.launch scenario:=tunnel_practice_1\n</pre></div>\n\n\n<p>You don't need to do this step unless you create a custom world file or modify an existing one because we are committing the <code>.dat</code> files.</p>\n<p><strong>Why are we committing the .dat (binary) files into the repository?</strong> We considered a couple of options, here\u2019s one:</p>\n<ul>\n<li>Launch the visibility.launch file when running the regular quickstart.launch . This was a promising idea but launch files are not enough to implement the logic that we want. We want to launch the visibility.launch first, and then, when the <code>.dat</code> file has been generated launch the quickstart.launch . We might use scripts instead, but given the different set of launch files that we have, it will complicate things unnecessary. The solution of checking in these <code>.dat</code> files is very simple (although I agree that not super elegant).</li>\n</ul>\n<p><strong>Developer bonus:</strong> I wouldn\u2019t officially advertise it but there\u2019s a service available (only if you\u2019re in the same machine as Gazebo)  to display all the areas of the world that are visible from the perspective of one robot. It uses Gazebo markers but it slows down gzclient a lot given the amount of markers published. You can type the following command from the console:</p>\n<div class=\"codehilite\"><pre><span></span>ign service -s /subt/comms_model/visualize --reqtype ignition.msgs.StringMsg --reptype ignition.msgs.Boolean  --timeout 60000 --req &#39;data: &quot;X1&quot;&#39;\n</pre></div>\n\n\n<p>Feel free to replace <code>X1</code> with the name of the robot you want to check.</p>", "type": "rendered"}, "source": {"commit": {"hash": "4dab21f6685c", "type": "commit", "links": {"self": {"href": "data/repositories/osrf/subt/commit/4dab21f6685c.json"}, "html": {"href": "#!/osrf/subt/commits/4dab21f6685c"}}}, "repository": {"links": {"self": {"href": "data/repositories/osrf/subt.json"}, "html": {"href": "#!/osrf/subt"}, "avatar": {"href": "data/bytebucket.org/ravatar/{3c95f6ad-c304-407c-b838-09597d836552}ts=2272898"}}, "type": "repository", "name": "subt", "full_name": "osrf/subt", "uuid": "{3c95f6ad-c304-407c-b838-09597d836552}"}, "branch": {"name": "visibility_lut"}}, "comment_count": 7, "state": "MERGED", "task_count": 0, "participants": [{"role": "PARTICIPANT", "participated_on": "2018-12-17T15:48:02.210229+00:00", "type": "participant", "approved": false, "user": {"display_name": "Jon Fink", "uuid": "{89cf7350-7d3a-4a2e-a6ce-43d49bfe9001}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B89cf7350-7d3a-4a2e-a6ce-43d49bfe9001%7D"}, "html": {"href": "https://bitbucket.org/%7B89cf7350-7d3a-4a2e-a6ce-43d49bfe9001%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/d3f96b67926116d5c1121e7dc9a1a8f2d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsJF-5.png"}}, "nickname": "jonfink-arl", "type": "user", "account_id": "5b90221dfa38ae2c89609691"}}, {"role": "PARTICIPANT", "participated_on": "2018-12-19T22:45:06.459691+00:00", "type": "participant", "approved": false, "user": {"display_name": "Carlos Ag\u00fcero", "uuid": "{da8a8e89-4bb0-421b-bd0e-dbbed3d4ed6a}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bda8a8e89-4bb0-421b-bd0e-dbbed3d4ed6a%7D"}, "html": {"href": "https://bitbucket.org/%7Bda8a8e89-4bb0-421b-bd0e-dbbed3d4ed6a%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/692bf15758111acaddae4da15a47f9e5d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCA-0.png"}}, "nickname": "caguero", "type": "user", "account_id": "557058:4ded1ddf-947e-4154-bbd1-3dba24f1bdbd"}}, {"role": "PARTICIPANT", "participated_on": "2019-01-02T16:45:38.424491+00:00", "type": "participant", "approved": true, "user": {"display_name": "Nate Koenig", "uuid": "{c862cdd9-fcc8-4419-9fc7-e20db14b8fcb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D"}, "html": {"href": "https://bitbucket.org/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:095b1e12-74ed-4e20-b44f-2f0745b616e0/ca24bb11-4787-4b14-a20d-d91835e9bde2/128"}}, "nickname": "Nathan Koenig", "type": "user", "account_id": "557058:095b1e12-74ed-4e20-b44f-2f0745b616e0"}}], "reason": "", "updated_on": "2019-01-02T18:39:01.231006+00:00", "author": {"display_name": "Carlos Ag\u00fcero", "uuid": "{da8a8e89-4bb0-421b-bd0e-dbbed3d4ed6a}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bda8a8e89-4bb0-421b-bd0e-dbbed3d4ed6a%7D"}, "html": {"href": "https://bitbucket.org/%7Bda8a8e89-4bb0-421b-bd0e-dbbed3d4ed6a%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/692bf15758111acaddae4da15a47f9e5d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCA-0.png"}}, "nickname": "caguero", "type": "user", "account_id": "557058:4ded1ddf-947e-4154-bbd1-3dba24f1bdbd"}, "merge_commit": {"hash": "ac1b9bbbc424", "type": "commit", "links": {"self": {"href": "data/repositories/osrf/subt/commit/ac1b9bbbc424.json"}, "html": {"href": "#!/osrf/subt/commits/ac1b9bbbc424"}}}, "closed_by": {"display_name": "Carlos Ag\u00fcero", "uuid": "{da8a8e89-4bb0-421b-bd0e-dbbed3d4ed6a}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bda8a8e89-4bb0-421b-bd0e-dbbed3d4ed6a%7D"}, "html": {"href": "https://bitbucket.org/%7Bda8a8e89-4bb0-421b-bd0e-dbbed3d4ed6a%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/692bf15758111acaddae4da15a47f9e5d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCA-0.png"}}, "nickname": "caguero", "type": "user", "account_id": "557058:4ded1ddf-947e-4154-bbd1-3dba24f1bdbd"}}