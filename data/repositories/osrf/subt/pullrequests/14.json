{"rendered": {"reason": {"raw": "This PR is declined. This approach generates launch and world files in runtime, but it was not necessary as far as a world file is generated in configuration time.", "markup": "markdown", "html": "<p>This PR is declined. This approach generates launch and world files in runtime, but it was not necessary as far as a world file is generated in configuration time.</p>", "type": "rendered"}, "description": {"raw": "Rostest examples dynamically generating launch and world files by a python script and yaml files.\r\n\r\nI mimicked the testing framework used in ARIAC [[https://bitbucket.org/osrf/ariac/src/master/](https://bitbucket.org/osrf/ariac/src/master/)](https://bitbucket.org/osrf/ariac/src/master). Along with its test node, each rostest file runs a node with python code \\(run\\_sim.py\\) which generates launch and world files based on settings in yaml files dynamically, and finally starts Gazebo simulator.\r\n\r\nThe original python script \\(gear.py\\) used in ARIAC is available at [https://bitbucket.org/osrf/ariac/src/master/osrf\\_gear/script/gear.py](https://bitbucket.org/osrf/ariac/src/master/osrf_gear/script/gear.py), which is also used for their competition. It converts template files \\(i.e., gear.launch.template, gear.world.template, etc\\) into actual launch and world files by empy based on parameters given in arguments and yaml files. In the python script of this PR, the parts specific to ARIAC were removed.\r\n\r\nThere are two rostest examples. Both of them just set up ros and gazebo transport node and exit, but the first one generates a world file while the second uses an existing world file specified in the arguments. Most of parameters in yaml files are just for example, and they don\u2019t do anything.\r\n\r\nIn stead of the template world file, I guess it is also possible to generate a random tunnel world by calling another python script in run\\_sim.py.\r\n\r\nI appreciate any comments and advice!", "markup": "markdown", "html": "<p>Rostest examples dynamically generating launch and world files by a python script and yaml files.</p>\n<p>I mimicked the testing framework used in ARIAC <a data-is-external-link=\"true\" href=\"https://bitbucket.org/osrf/ariac/src/master\" rel=\"nofollow\">[https://bitbucket.org/osrf/ariac/src/master/](https://bitbucket.org/osrf/ariac/src/master/)</a>. Along with its test node, each rostest file runs a node with python code (run_sim.py) which generates launch and world files based on settings in yaml files dynamically, and finally starts Gazebo simulator.</p>\n<p>The original python script (gear.py) used in ARIAC is available at <a data-is-external-link=\"true\" href=\"https://bitbucket.org/osrf/ariac/src/master/osrf_gear/script/gear.py\" rel=\"nofollow\">https://bitbucket.org/osrf/ariac/src/master/osrf_gear/script/gear.py</a>, which is also used for their competition. It converts template files (i.e., gear.launch.template, gear.world.template, etc) into actual launch and world files by empy based on parameters given in arguments and yaml files. In the python script of this PR, the parts specific to ARIAC were removed.</p>\n<p>There are two rostest examples. Both of them just set up ros and gazebo transport node and exit, but the first one generates a world file while the second uses an existing world file specified in the arguments. Most of parameters in yaml files are just for example, and they don\u2019t do anything.</p>\n<p>In stead of the template world file, I guess it is also possible to generate a random tunnel world by calling another python script in run_sim.py.</p>\n<p>I appreciate any comments and advice!</p>", "type": "rendered"}, "title": {"raw": "Rostest examples configurable by python and yaml", "markup": "markdown", "html": "<p>Rostest examples configurable by python and yaml</p>", "type": "rendered"}}, "type": "pullrequest", "description": "Rostest examples dynamically generating launch and world files by a python script and yaml files.\r\n\r\nI mimicked the testing framework used in ARIAC [[https://bitbucket.org/osrf/ariac/src/master/](https://bitbucket.org/osrf/ariac/src/master/)](https://bitbucket.org/osrf/ariac/src/master). Along with its test node, each rostest file runs a node with python code \\(run\\_sim.py\\) which generates launch and world files based on settings in yaml files dynamically, and finally starts Gazebo simulator.\r\n\r\nThe original python script \\(gear.py\\) used in ARIAC is available at [https://bitbucket.org/osrf/ariac/src/master/osrf\\_gear/script/gear.py](https://bitbucket.org/osrf/ariac/src/master/osrf_gear/script/gear.py), which is also used for their competition. It converts template files \\(i.e., gear.launch.template, gear.world.template, etc\\) into actual launch and world files by empy based on parameters given in arguments and yaml files. In the python script of this PR, the parts specific to ARIAC were removed.\r\n\r\nThere are two rostest examples. Both of them just set up ros and gazebo transport node and exit, but the first one generates a world file while the second uses an existing world file specified in the arguments. Most of parameters in yaml files are just for example, and they don\u2019t do anything.\r\n\r\nIn stead of the template world file, I guess it is also possible to generate a random tunnel world by calling another python script in run\\_sim.py.\r\n\r\nI appreciate any comments and advice!", "links": {"decline": {"href": "https://api.bitbucket.org/2.0/repositories/osrf/subt/pullrequests/14/decline"}, "diffstat": {"href": "https://api.bitbucket.org/2.0/repositories/osrf/subt/diffstat/osrf/subt:9b885c727c21%0D6147d316bb85?from_pullrequest_id=14"}, "commits": {"href": "data/repositories/osrf/subt/pullrequests/14/commits.json"}, "self": {"href": "data/repositories/osrf/subt/pullrequests/14.json"}, "comments": {"href": "data/repositories/osrf/subt/pullrequests/14/comments_page=1.json"}, "merge": {"href": "https://api.bitbucket.org/2.0/repositories/osrf/subt/pullrequests/14/merge"}, "html": {"href": "#!/osrf/subt/pull-requests/14"}, "activity": {"href": "data/repositories/osrf/subt/pullrequests/14/activity.json"}, "diff": {"href": "https://api.bitbucket.org/2.0/repositories/osrf/subt/diff/osrf/subt:9b885c727c21%0D6147d316bb85?from_pullrequest_id=14"}, "approve": {"href": "https://api.bitbucket.org/2.0/repositories/osrf/subt/pullrequests/14/approve"}, "statuses": {"href": "data/repositories/osrf/subt/pullrequests/14/statuses_page=1.json"}}, "title": "Rostest examples configurable by python and yaml", "close_source_branch": false, "reviewers": [], "id": 14, "destination": {"commit": {"hash": "6147d316bb85", "type": "commit", "links": {"self": {"href": "data/repositories/osrf/subt/commit/6147d316bb85.json"}, "html": {"href": "#!/osrf/subt/commits/6147d316bb85"}}}, "repository": {"links": {"self": {"href": "data/repositories/osrf/subt.json"}, "html": {"href": "#!/osrf/subt"}, "avatar": {"href": "data/bytebucket.org/ravatar/{3c95f6ad-c304-407c-b838-09597d836552}ts=2272898"}}, "type": "repository", "name": "subt", "full_name": "osrf/subt", "uuid": "{3c95f6ad-c304-407c-b838-09597d836552}"}, "branch": {"name": "default"}}, "created_on": "2018-06-13T22:13:21.224628+00:00", "summary": {"raw": "Rostest examples dynamically generating launch and world files by a python script and yaml files.\r\n\r\nI mimicked the testing framework used in ARIAC [[https://bitbucket.org/osrf/ariac/src/master/](https://bitbucket.org/osrf/ariac/src/master/)](https://bitbucket.org/osrf/ariac/src/master). Along with its test node, each rostest file runs a node with python code \\(run\\_sim.py\\) which generates launch and world files based on settings in yaml files dynamically, and finally starts Gazebo simulator.\r\n\r\nThe original python script \\(gear.py\\) used in ARIAC is available at [https://bitbucket.org/osrf/ariac/src/master/osrf\\_gear/script/gear.py](https://bitbucket.org/osrf/ariac/src/master/osrf_gear/script/gear.py), which is also used for their competition. It converts template files \\(i.e., gear.launch.template, gear.world.template, etc\\) into actual launch and world files by empy based on parameters given in arguments and yaml files. In the python script of this PR, the parts specific to ARIAC were removed.\r\n\r\nThere are two rostest examples. Both of them just set up ros and gazebo transport node and exit, but the first one generates a world file while the second uses an existing world file specified in the arguments. Most of parameters in yaml files are just for example, and they don\u2019t do anything.\r\n\r\nIn stead of the template world file, I guess it is also possible to generate a random tunnel world by calling another python script in run\\_sim.py.\r\n\r\nI appreciate any comments and advice!", "markup": "markdown", "html": "<p>Rostest examples dynamically generating launch and world files by a python script and yaml files.</p>\n<p>I mimicked the testing framework used in ARIAC <a data-is-external-link=\"true\" href=\"https://bitbucket.org/osrf/ariac/src/master\" rel=\"nofollow\">[https://bitbucket.org/osrf/ariac/src/master/](https://bitbucket.org/osrf/ariac/src/master/)</a>. Along with its test node, each rostest file runs a node with python code (run_sim.py) which generates launch and world files based on settings in yaml files dynamically, and finally starts Gazebo simulator.</p>\n<p>The original python script (gear.py) used in ARIAC is available at <a data-is-external-link=\"true\" href=\"https://bitbucket.org/osrf/ariac/src/master/osrf_gear/script/gear.py\" rel=\"nofollow\">https://bitbucket.org/osrf/ariac/src/master/osrf_gear/script/gear.py</a>, which is also used for their competition. It converts template files (i.e., gear.launch.template, gear.world.template, etc) into actual launch and world files by empy based on parameters given in arguments and yaml files. In the python script of this PR, the parts specific to ARIAC were removed.</p>\n<p>There are two rostest examples. Both of them just set up ros and gazebo transport node and exit, but the first one generates a world file while the second uses an existing world file specified in the arguments. Most of parameters in yaml files are just for example, and they don\u2019t do anything.</p>\n<p>In stead of the template world file, I guess it is also possible to generate a random tunnel world by calling another python script in run_sim.py.</p>\n<p>I appreciate any comments and advice!</p>", "type": "rendered"}, "source": {"commit": {"hash": "9b885c727c21", "type": "commit", "links": {"self": {"href": "data/repositories/osrf/subt/commit/9b885c727c21.json"}, "html": {"href": "#!/osrf/subt/commits/9b885c727c21"}}}, "repository": {"links": {"self": {"href": "data/repositories/osrf/subt.json"}, "html": {"href": "#!/osrf/subt"}, "avatar": {"href": "data/bytebucket.org/ravatar/{3c95f6ad-c304-407c-b838-09597d836552}ts=2272898"}}, "type": "repository", "name": "subt", "full_name": "osrf/subt", "uuid": "{3c95f6ad-c304-407c-b838-09597d836552}"}, "branch": {"name": "rostest_example"}}, "comment_count": 0, "state": "DECLINED", "task_count": 0, "participants": [], "reason": "This PR is declined. This approach generates launch and world files in runtime, but it was not necessary as far as a world file is generated in configuration time.", "updated_on": "2018-06-14T18:03:13.023268+00:00", "author": {"display_name": "Tetsuya Idota", "uuid": "{e3645666-978a-455a-85c4-dcc342a8d822}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be3645666-978a-455a-85c4-dcc342a8d822%7D"}, "html": {"href": "https://bitbucket.org/%7Be3645666-978a-455a-85c4-dcc342a8d822%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/8cb890d7583a1f6b8a01419ebed6ac26d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsTI-1.png"}}, "nickname": "tidota", "type": "user", "account_id": "5aa97fa8e78b8c2a7c886fd3"}, "merge_commit": null, "closed_by": {"display_name": "Tetsuya Idota", "uuid": "{e3645666-978a-455a-85c4-dcc342a8d822}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be3645666-978a-455a-85c4-dcc342a8d822%7D"}, "html": {"href": "https://bitbucket.org/%7Be3645666-978a-455a-85c4-dcc342a8d822%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/8cb890d7583a1f6b8a01419ebed6ac26d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsTI-1.png"}}, "nickname": "tidota", "type": "user", "account_id": "5aa97fa8e78b8c2a7c886fd3"}}