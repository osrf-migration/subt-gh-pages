{"pagelen": 50, "values": [{"update": {"description": "**Motivation**: Before this pull request, one of the parameters of the communication model is distance between source and destination. For SubT, distance is not very appropriate because source and destination could be very close but with a thick wall in between. Similarly, source and destination could be far but within line of sight across a straight section of a tunnel. This pull request introduces a new replacement for distance: connectivity cost.\r\n\r\n**Changes to world files**: After this pull request, a SubT world requires three different files:\r\n\r\n* <SCENARIO>.world: The regular Gazebo world file. Nothing changes here.\r\n* <SCENARIO>.dot: This text file captures the topological map of the scenario. Each section of the scenario \\(e.g.: a tunnel tile, the staging area\\) is a vertex of a graph and all pairs of sections physically connected in the world are connected with an edge in the graph. Additionally, vertices capture the model type and model name in case is relevant for the future.\r\n* <SCENARIO>.dat: This binary file is a look-up-table used by the communication model. The content of this file is a sequence of tuples with the format `<int32_t, int32_t, int32_t, uint64_t>`. The first three elements represent a 3D point and the last element is the Id of the vertex associated to the model that surrounds the previous point.\r\n\r\n**Changes to the communication model:** After this pull request, the communication model loads the `.dat` and `.dot` files associated to the current Gazebo world. The `.dot` file is used to create an in-memory graph. We run `Dijkstra` on this graph to get the cost of traversing any pair of vertices. The `.dat` file is used to convert a 3D point to the vertex Id where the point is located. This will be relevant when we have two robots located in two 3D coordinates of the world. We need to know which vertices correspond to those two points. When we have the two vertex Ids, we can use the information that we got after running `Dijkstra` to get the associated cost of the path connecting the two robots. The SubT message is discarded if the cost is higher than a given threshold. This threshold is a new parameter of the communication model named `comms_cost_max`.\r\n\r\n**How are the costs being assigned to each edge in the graph?** Manually and based on the next heuristic:\r\n\r\n* Straight section <-> straight section:`1`\r\n* Straight section <-> non-straight section:`3`\r\n* Non-straight section <-> non-straight section:`6`\r\n\r\n**How do I \\[re\\]generate a** `.dat` **file?** Let's use an example for generating `tunnel_practice_1.dat`:\r\n\r\n    roslaunch subt_gazebo visibility.launch scenario:=tunnel_practice_1\r\n\r\nYou don't need to do this step unless you create a custom world file or modify an existing one because we are committing the `.dat` files.\r\n\r\n**Why are we committing the .dat \\(binary\\) files into the repository?** We considered a couple of options, here\u2019s one:\r\n\r\n* Launch the visibility.launch file when running the regular quickstart.launch . This was a promising idea but launch files are not enough to implement the logic that we want. We want to launch the visibility.launch first, and then, when the `.dat` file has been generated launch the quickstart.launch . We might use scripts instead, but given the different set of launch files that we have, it will complicate things unnecessary. The solution of checking in these `.dat` files is very simple \\(although I agree that not super elegant\\).\r\n\r\n**Developer bonus:** I wouldn\u2019t officially advertise it but there\u2019s a service available \\(only if you\u2019re in the same machine as Gazebo\\)  to display all the areas of the world that are visible from the perspective of one robot. It uses Gazebo markers but it slows down gzclient a lot given the amount of markers published. You can type the following command from the console:\r\n\r\n    ign service -s /subt/comms_model/visualize --reqtype ignition.msgs.StringMsg --reptype ignition.msgs.Boolean  --timeout 60000 --req 'data: \"X1\"'\r\n\r\nFeel free to replace `X1` with the name of the robot you want to check.", "title": "Communication model based on graph cost", "destination": {"commit": {"hash": "a53fb3eb6a81", "type": "commit", "links": {"self": {"href": "data/repositories/osrf/subt/commit/a53fb3eb6a81.json"}, "html": {"href": "#!/osrf/subt/commits/a53fb3eb6a81"}}}, "repository": {"links": {"self": {"href": "data/repositories/osrf/subt.json"}, "html": {"href": "#!/osrf/subt"}, "avatar": {"href": "data/bytebucket.org/ravatar/{3c95f6ad-c304-407c-b838-09597d836552}ts=2272898"}}, "type": "repository", "name": "subt", "full_name": "osrf/subt", "uuid": "{3c95f6ad-c304-407c-b838-09597d836552}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "4dab21f6685c", "type": "commit", "links": {"self": {"href": "data/repositories/osrf/subt/commit/4dab21f6685c.json"}, "html": {"href": "#!/osrf/subt/commits/4dab21f6685c"}}}, "repository": {"links": {"self": {"href": "data/repositories/osrf/subt.json"}, "html": {"href": "#!/osrf/subt"}, "avatar": {"href": "data/bytebucket.org/ravatar/{3c95f6ad-c304-407c-b838-09597d836552}ts=2272898"}}, "type": "repository", "name": "subt", "full_name": "osrf/subt", "uuid": "{3c95f6ad-c304-407c-b838-09597d836552}"}, "branch": {"name": "visibility_lut"}}, "state": "MERGED", "author": {"display_name": "Carlos Ag\u00fcero", "uuid": "{da8a8e89-4bb0-421b-bd0e-dbbed3d4ed6a}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bda8a8e89-4bb0-421b-bd0e-dbbed3d4ed6a%7D"}, "html": {"href": "https://bitbucket.org/%7Bda8a8e89-4bb0-421b-bd0e-dbbed3d4ed6a%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/692bf15758111acaddae4da15a47f9e5d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCA-0.png"}}, "nickname": "caguero", "type": "user", "account_id": "557058:4ded1ddf-947e-4154-bbd1-3dba24f1bdbd"}, "date": "2019-01-02T18:39:01.246213+00:00"}, "pull_request": {"type": "pullrequest", "id": 95, "links": {"self": {"href": "data/repositories/osrf/subt/pullrequests/95.json"}, "html": {"href": "#!/osrf/subt/pull-requests/95"}}, "title": "Communication model based on graph cost"}}, {"approval": {"date": "2019-01-02T16:45:38.424491+00:00", "pullrequest": {"type": "pullrequest", "id": 95, "links": {"self": {"href": "data/repositories/osrf/subt/pullrequests/95.json"}, "html": {"href": "#!/osrf/subt/pull-requests/95"}}, "title": "Communication model based on graph cost"}, "user": {"display_name": "Nate Koenig", "uuid": "{c862cdd9-fcc8-4419-9fc7-e20db14b8fcb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D"}, "html": {"href": "https://bitbucket.org/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:095b1e12-74ed-4e20-b44f-2f0745b616e0/ca24bb11-4787-4b14-a20d-d91835e9bde2/128"}}, "nickname": "Nathan Koenig", "type": "user", "account_id": "557058:095b1e12-74ed-4e20-b44f-2f0745b616e0"}}, "pull_request": {"type": "pullrequest", "id": 95, "links": {"self": {"href": "data/repositories/osrf/subt/pullrequests/95.json"}, "html": {"href": "#!/osrf/subt/pull-requests/95"}}, "title": "Communication model based on graph cost"}}, {"comment": {"links": {"self": {"href": "data/repositories/osrf/subt/pullrequests/95/comments/86894955.json"}, "html": {"href": "#!/osrf/subt/pull-requests/95/_/diff#comment-86894955"}}, "parent": {"id": 86102065, "links": {"self": {"href": "data/repositories/osrf/subt/pullrequests/95/comments/86102065.json"}, "html": {"href": "#!/osrf/subt/pull-requests/95/_/diff#comment-86102065"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 95, "links": {"self": {"href": "data/repositories/osrf/subt/pullrequests/95.json"}, "html": {"href": "#!/osrf/subt/pull-requests/95"}}, "title": "Communication model based on graph cost"}, "content": {"raw": "This is working for me after I cleaned up some other libraries on my machine.", "markup": "markdown", "html": "<p>This is working for me after I cleaned up some other libraries on my machine.</p>", "type": "rendered"}, "created_on": "2019-01-02T16:42:35.175515+00:00", "user": {"display_name": "Nate Koenig", "uuid": "{c862cdd9-fcc8-4419-9fc7-e20db14b8fcb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D"}, "html": {"href": "https://bitbucket.org/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:095b1e12-74ed-4e20-b44f-2f0745b616e0/ca24bb11-4787-4b14-a20d-d91835e9bde2/128"}}, "nickname": "Nathan Koenig", "type": "user", "account_id": "557058:095b1e12-74ed-4e20-b44f-2f0745b616e0"}, "updated_on": "2019-01-02T16:42:35.188409+00:00", "type": "pullrequest_comment", "id": 86894955}, "pull_request": {"type": "pullrequest", "id": 95, "links": {"self": {"href": "data/repositories/osrf/subt/pullrequests/95.json"}, "html": {"href": "#!/osrf/subt/pull-requests/95"}}, "title": "Communication model based on graph cost"}}, {"comment": {"links": {"self": {"href": "data/repositories/osrf/subt/pullrequests/95/comments/86101972.json"}, "html": {"href": "#!/osrf/subt/pull-requests/95/_/diff#comment-86101972"}}, "parent": {"id": 85898886, "links": {"self": {"href": "data/repositories/osrf/subt/pullrequests/95/comments/85898886.json"}, "html": {"href": "#!/osrf/subt/pull-requests/95/_/diff#comment-85898886"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 95, "links": {"self": {"href": "data/repositories/osrf/subt/pullrequests/95.json"}, "html": {"href": "#!/osrf/subt/pull-requests/95"}}, "title": "Communication model based on graph cost"}, "content": {"raw": "Exactly, the purpose is to get the vertex ID for the graph.\n\nWe could get the vertex Id at runtime but we would need to check AABB collisions between the current model\u2019s bounding box and the rest of the tiles. This might be computational expensive, as this is something to do every iteration.", "markup": "markdown", "html": "<p>Exactly, the purpose is to get the vertex ID for the graph.</p>\n<p>We could get the vertex Id at runtime but we would need to check AABB collisions between the current model\u2019s bounding box and the rest of the tiles. This might be computational expensive, as this is something to do every iteration.</p>", "type": "rendered"}, "created_on": "2018-12-18T23:21:39.680671+00:00", "user": {"display_name": "Carlos Ag\u00fcero", "uuid": "{da8a8e89-4bb0-421b-bd0e-dbbed3d4ed6a}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bda8a8e89-4bb0-421b-bd0e-dbbed3d4ed6a%7D"}, "html": {"href": "https://bitbucket.org/%7Bda8a8e89-4bb0-421b-bd0e-dbbed3d4ed6a%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/692bf15758111acaddae4da15a47f9e5d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCA-0.png"}}, "nickname": "caguero", "type": "user", "account_id": "557058:4ded1ddf-947e-4154-bbd1-3dba24f1bdbd"}, "updated_on": "2018-12-19T22:45:06.459691+00:00", "type": "pullrequest_comment", "id": 86101972}, "pull_request": {"type": "pullrequest", "id": 95, "links": {"self": {"href": "data/repositories/osrf/subt/pullrequests/95.json"}, "html": {"href": "#!/osrf/subt/pull-requests/95"}}, "title": "Communication model based on graph cost"}}, {"comment": {"links": {"self": {"href": "data/repositories/osrf/subt/pullrequests/95/comments/86104641.json"}, "html": {"href": "#!/osrf/subt/pull-requests/95/_/diff#comment-86104641"}}, "parent": {"id": 85306745, "links": {"self": {"href": "data/repositories/osrf/subt/pullrequests/95/comments/85306745.json"}, "html": {"href": "#!/osrf/subt/pull-requests/95/_/diff#comment-85306745"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 95, "links": {"self": {"href": "data/repositories/osrf/subt/pullrequests/95.json"}, "html": {"href": "#!/osrf/subt/pull-requests/95"}}, "title": "Communication model based on graph cost"}, "content": {"raw": "We could if we assume that the only models in the world are the tiles. These constants are also used in the visualization function \\(_CommsModel::VisualizeVisibility\\(\\)_\\). I think we might need to add the limits found while building the LUT into the .dat file. ", "markup": "markdown", "html": "<p>We could if we assume that the only models in the world are the tiles. These constants are also used in the visualization function (<em>CommsModel::VisualizeVisibility()</em>). I think we might need to add the limits found while building the LUT into the .dat file. </p>", "type": "rendered"}, "created_on": "2018-12-19T00:05:48.413955+00:00", "user": {"display_name": "Carlos Ag\u00fcero", "uuid": "{da8a8e89-4bb0-421b-bd0e-dbbed3d4ed6a}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bda8a8e89-4bb0-421b-bd0e-dbbed3d4ed6a%7D"}, "html": {"href": "https://bitbucket.org/%7Bda8a8e89-4bb0-421b-bd0e-dbbed3d4ed6a%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/692bf15758111acaddae4da15a47f9e5d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCA-0.png"}}, "nickname": "caguero", "type": "user", "account_id": "557058:4ded1ddf-947e-4154-bbd1-3dba24f1bdbd"}, "inline": {}, "updated_on": "2018-12-19T00:06:55.565274+00:00", "type": "pullrequest_comment", "id": 86104641}, "pull_request": {"type": "pullrequest", "id": 95, "links": {"self": {"href": "data/repositories/osrf/subt/pullrequests/95.json"}, "html": {"href": "#!/osrf/subt/pull-requests/95"}}, "title": "Communication model based on graph cost"}}, {"comment": {"links": {"self": {"href": "data/repositories/osrf/subt/pullrequests/95/comments/86102065.json"}, "html": {"href": "#!/osrf/subt/pull-requests/95/_/diff#comment-86102065"}}, "parent": {"id": 85305378, "links": {"self": {"href": "data/repositories/osrf/subt/pullrequests/95/comments/85305378.json"}, "html": {"href": "#!/osrf/subt/pull-requests/95/_/diff#comment-85305378"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 95, "links": {"self": {"href": "data/repositories/osrf/subt/pullrequests/95.json"}, "html": {"href": "#!/osrf/subt/pull-requests/95"}}, "title": "Communication model based on graph cost"}, "content": {"raw": "Hmm, I cannot reproduce the error with my laptop or desktop. Out of curiosity, can you launch the simulation?", "markup": "markdown", "html": "<p>Hmm, I cannot reproduce the error with my laptop or desktop. Out of curiosity, can you launch the simulation?</p>", "type": "rendered"}, "created_on": "2018-12-18T23:23:05.482293+00:00", "user": {"display_name": "Carlos Ag\u00fcero", "uuid": "{da8a8e89-4bb0-421b-bd0e-dbbed3d4ed6a}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bda8a8e89-4bb0-421b-bd0e-dbbed3d4ed6a%7D"}, "html": {"href": "https://bitbucket.org/%7Bda8a8e89-4bb0-421b-bd0e-dbbed3d4ed6a%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/692bf15758111acaddae4da15a47f9e5d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCA-0.png"}}, "nickname": "caguero", "type": "user", "account_id": "557058:4ded1ddf-947e-4154-bbd1-3dba24f1bdbd"}, "updated_on": "2018-12-18T23:23:05.492499+00:00", "type": "pullrequest_comment", "id": 86102065}, "pull_request": {"type": "pullrequest", "id": 95, "links": {"self": {"href": "data/repositories/osrf/subt/pullrequests/95.json"}, "html": {"href": "#!/osrf/subt/pull-requests/95"}}, "title": "Communication model based on graph cost"}}, {"comment": {"links": {"self": {"href": "data/repositories/osrf/subt/pullrequests/95/comments/85898886.json"}, "html": {"href": "#!/osrf/subt/pull-requests/95/_/diff#comment-85898886"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 95, "links": {"self": {"href": "data/repositories/osrf/subt/pullrequests/95.json"}, "html": {"href": "#!/osrf/subt/pull-requests/95"}}, "title": "Communication model based on graph cost"}, "content": {"raw": "Is the purpose of the  `.dat` file only to figure out which SUBT tile the robot is currently occupying \\(thus, getting the vertex ID for the graph in the `.dot`file\\)? If so, aren\u2019t we already effectively computing this as part of Gazebo\u2019s AABB collision check routine? ", "markup": "markdown", "html": "<p>Is the purpose of the  <code>.dat</code> file only to figure out which SUBT tile the robot is currently occupying (thus, getting the vertex ID for the graph in the <code>.dot</code>file)? If so, aren\u2019t we already effectively computing this as part of Gazebo\u2019s AABB collision check routine? </p>", "type": "rendered"}, "created_on": "2018-12-17T15:48:02.114669+00:00", "user": {"display_name": "Jon Fink", "uuid": "{89cf7350-7d3a-4a2e-a6ce-43d49bfe9001}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B89cf7350-7d3a-4a2e-a6ce-43d49bfe9001%7D"}, "html": {"href": "https://bitbucket.org/%7B89cf7350-7d3a-4a2e-a6ce-43d49bfe9001%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/d3f96b67926116d5c1121e7dc9a1a8f2d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsJF-5.png"}}, "nickname": "jonfink-arl", "type": "user", "account_id": "5b90221dfa38ae2c89609691"}, "updated_on": "2018-12-17T15:48:02.210229+00:00", "type": "pullrequest_comment", "id": 85898886}, "pull_request": {"type": "pullrequest", "id": 95, "links": {"self": {"href": "data/repositories/osrf/subt/pullrequests/95.json"}, "html": {"href": "#!/osrf/subt/pull-requests/95"}}, "title": "Communication model based on graph cost"}}, {"comment": {"links": {"self": {"href": "data/repositories/osrf/subt/pullrequests/95/comments/85306745.json"}, "html": {"href": "#!/osrf/subt/pull-requests/95/_/diff#comment-85306745"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 95, "links": {"self": {"href": "data/repositories/osrf/subt/pullrequests/95.json"}, "html": {"href": "#!/osrf/subt/pull-requests/95"}}, "title": "Communication model based on graph cost"}, "content": {"raw": "Is it possible to calculate the bounds from the world file instead of manually specify the bounds here? For example, you could iterate over all the models in the world to find the extents.", "markup": "markdown", "html": "<p>Is it possible to calculate the bounds from the world file instead of manually specify the bounds here? For example, you could iterate over all the models in the world to find the extents.</p>", "type": "rendered"}, "created_on": "2018-12-11T17:00:40.615715+00:00", "user": {"display_name": "Nate Koenig", "uuid": "{c862cdd9-fcc8-4419-9fc7-e20db14b8fcb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D"}, "html": {"href": "https://bitbucket.org/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:095b1e12-74ed-4e20-b44f-2f0745b616e0/ca24bb11-4787-4b14-a20d-d91835e9bde2/128"}}, "nickname": "Nathan Koenig", "type": "user", "account_id": "557058:095b1e12-74ed-4e20-b44f-2f0745b616e0"}, "inline": {}, "updated_on": "2018-12-11T17:00:40.622284+00:00", "type": "pullrequest_comment", "id": 85306745}, "pull_request": {"type": "pullrequest", "id": 95, "links": {"self": {"href": "data/repositories/osrf/subt/pullrequests/95.json"}, "html": {"href": "#!/osrf/subt/pull-requests/95"}}, "title": "Communication model based on graph cost"}}, {"comment": {"links": {"self": {"href": "data/repositories/osrf/subt/pullrequests/95/comments/85305378.json"}, "html": {"href": "#!/osrf/subt/pull-requests/95/_/diff#comment-85305378"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 95, "links": {"self": {"href": "data/repositories/osrf/subt/pullrequests/95.json"}, "html": {"href": "#!/osrf/subt/pull-requests/95"}}, "title": "Communication model based on graph cost"}, "content": {"raw": "After a fresh install, I run `roslaunch subt_gazebo visibility.launch scenario:=tunnel_practice_1` and I get the following error:\n\n```\nBuilding LUT\n100 %\ncorrupted size vs. prev_size\nAborted (core dumped)\n[gazebo-2] process has died [pid 10066, exit code 134, cmd /opt/ros/melodic/lib/gazebo_ros/gzserver -e ode -s libVisibilityPlugin.so --verbose /home/nkoenig/subt_ws/install/share/subt_gazebo/worlds/tunnel_practice_1.world __name:=gazebo __log:=/home/nkoenig/.ros/log/1dc4cb0c-fd63-11e8-ad26-ac9e17b7716c/gazebo-2.log].\nlog file: /home/nkoenig/.ros/log/1dc4cb0c-fd63-11e8-ad26-ac9e17b7716c/gazebo-2*.log\n```\n\nI also deleted the `tunnel_practice_1.dat` file, ran the same launch file and the result was the same.", "markup": "markdown", "html": "<p>After a fresh install, I run <code>roslaunch subt_gazebo visibility.launch scenario:=tunnel_practice_1</code> and I get the following error:</p>\n<div class=\"codehilite\"><pre><span></span>Building LUT\n100 %\ncorrupted size vs. prev_size\nAborted (core dumped)\n[gazebo-2] process has died [pid 10066, exit code 134, cmd /opt/ros/melodic/lib/gazebo_ros/gzserver -e ode -s libVisibilityPlugin.so --verbose /home/nkoenig/subt_ws/install/share/subt_gazebo/worlds/tunnel_practice_1.world __name:=gazebo __log:=/home/nkoenig/.ros/log/1dc4cb0c-fd63-11e8-ad26-ac9e17b7716c/gazebo-2.log].\nlog file: /home/nkoenig/.ros/log/1dc4cb0c-fd63-11e8-ad26-ac9e17b7716c/gazebo-2*.log\n</pre></div>\n\n\n<p>I also deleted the <code>tunnel_practice_1.dat</code> file, ran the same launch file and the result was the same.</p>", "type": "rendered"}, "created_on": "2018-12-11T16:52:36.691792+00:00", "user": {"display_name": "Nate Koenig", "uuid": "{c862cdd9-fcc8-4419-9fc7-e20db14b8fcb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D"}, "html": {"href": "https://bitbucket.org/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:095b1e12-74ed-4e20-b44f-2f0745b616e0/ca24bb11-4787-4b14-a20d-d91835e9bde2/128"}}, "nickname": "Nathan Koenig", "type": "user", "account_id": "557058:095b1e12-74ed-4e20-b44f-2f0745b616e0"}, "updated_on": "2018-12-11T16:52:36.702080+00:00", "type": "pullrequest_comment", "id": 85305378}, "pull_request": {"type": "pullrequest", "id": 95, "links": {"self": {"href": "data/repositories/osrf/subt/pullrequests/95.json"}, "html": {"href": "#!/osrf/subt/pull-requests/95"}}, "title": "Communication model based on graph cost"}}, {"update": {"description": "**Motivation**: Before this pull request, one of the parameters of the communication model is distance between source and destination. For SubT, distance is not very appropriate because source and destination could be very close but with a thick wall in between. Similarly, source and destination could be far but within line of sight across a straight section of a tunnel. This pull request introduces a new replacement for distance: connectivity cost.\r\n\r\n**Changes to world files**: After this pull request, a SubT world requires three different files:\r\n\r\n* <SCENARIO>.world: The regular Gazebo world file. Nothing changes here.\r\n* <SCENARIO>.dot: This text file captures the topological map of the scenario. Each section of the scenario \\(e.g.: a tunnel tile, the staging area\\) is a vertex of a graph and all pairs of sections physically connected in the world are connected with an edge in the graph. Additionally, vertices capture the model type and model name in case is relevant for the future.\r\n* <SCENARIO>.dat: This binary file is a look-up-table used by the communication model. The content of this file is a sequence of tuples with the format `<int32_t, int32_t, int32_t, uint64_t>`. The first three elements represent a 3D point and the last element is the Id of the vertex associated to the model that surrounds the previous point.\r\n\r\n**Changes to the communication model:** After this pull request, the communication model loads the `.dat` and `.dot` files associated to the current Gazebo world. The `.dot` file is used to create an in-memory graph. We run `Dijkstra` on this graph to get the cost of traversing any pair of vertices. The `.dat` file is used to convert a 3D point to the vertex Id where the point is located. This will be relevant when we have two robots located in two 3D coordinates of the world. We need to know which vertices correspond to those two points. When we have the two vertex Ids, we can use the information that we got after running `Dijkstra` to get the associated cost of the path connecting the two robots. The SubT message is discarded if the cost is higher than a given threshold. This threshold is a new parameter of the communication model named `comms_cost_max`.\r\n\r\n**How are the costs being assigned to each edge in the graph?** Manually and based on the next heuristic:\r\n\r\n* Straight section <-> straight section:`1`\r\n* Straight section <-> non-straight section:`3`\r\n* Non-straight section <-> non-straight section:`6`\r\n\r\n**How do I \\[re\\]generate a** `.dat` **file?** Let's use an example for generating `tunnel_practice_1.dat`:\r\n\r\n    roslaunch subt_gazebo visibility.launch scenario:=tunnel_practice_1\r\n\r\nYou don't need to do this step unless you create a custom world file or modify an existing one because we are committing the `.dat` files.\r\n\r\n**Why are we committing the .dat \\(binary\\) files into the repository?** We considered a couple of options, here\u2019s one:\r\n\r\n* Launch the visibility.launch file when running the regular quickstart.launch . This was a promising idea but launch files are not enough to implement the logic that we want. We want to launch the visibility.launch first, and then, when the `.dat` file has been generated launch the quickstart.launch . We might use scripts instead, but given the different set of launch files that we have, it will complicate things unnecessary. The solution of checking in these `.dat` files is very simple \\(although I agree that not super elegant\\).\r\n\r\n**Developer bonus:** I wouldn\u2019t officially advertise it but there\u2019s a service available \\(only if you\u2019re in the same machine as Gazebo\\)  to display all the areas of the world that are visible from the perspective of one robot. It uses Gazebo markers but it slows down gzclient a lot given the amount of markers published. You can type the following command from the console:\r\n\r\n    ign service -s /subt/comms_model/visualize --reqtype ignition.msgs.StringMsg --reptype ignition.msgs.Boolean  --timeout 60000 --req 'data: \"X1\"'\r\n\r\nFeel free to replace `X1` with the name of the robot you want to check.", "title": "Communication model based on graph cost", "destination": {"commit": {"hash": "ac3cd9a6a065", "type": "commit", "links": {"self": {"href": "data/repositories/osrf/subt/commit/ac3cd9a6a065.json"}, "html": {"href": "#!/osrf/subt/commits/ac3cd9a6a065"}}}, "repository": {"links": {"self": {"href": "data/repositories/osrf/subt.json"}, "html": {"href": "#!/osrf/subt"}, "avatar": {"href": "data/bytebucket.org/ravatar/{3c95f6ad-c304-407c-b838-09597d836552}ts=2272898"}}, "type": "repository", "name": "subt", "full_name": "osrf/subt", "uuid": "{3c95f6ad-c304-407c-b838-09597d836552}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "4dab21f6685c", "type": "commit", "links": {"self": {"href": "data/repositories/osrf/subt/commit/4dab21f6685c.json"}, "html": {"href": "#!/osrf/subt/commits/4dab21f6685c"}}}, "repository": {"links": {"self": {"href": "data/repositories/osrf/subt.json"}, "html": {"href": "#!/osrf/subt"}, "avatar": {"href": "data/bytebucket.org/ravatar/{3c95f6ad-c304-407c-b838-09597d836552}ts=2272898"}}, "type": "repository", "name": "subt", "full_name": "osrf/subt", "uuid": "{3c95f6ad-c304-407c-b838-09597d836552}"}, "branch": {"name": "visibility_lut"}}, "state": "OPEN", "author": {"display_name": "Carlos Ag\u00fcero", "uuid": "{da8a8e89-4bb0-421b-bd0e-dbbed3d4ed6a}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bda8a8e89-4bb0-421b-bd0e-dbbed3d4ed6a%7D"}, "html": {"href": "https://bitbucket.org/%7Bda8a8e89-4bb0-421b-bd0e-dbbed3d4ed6a%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/692bf15758111acaddae4da15a47f9e5d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCA-0.png"}}, "nickname": "caguero", "type": "user", "account_id": "557058:4ded1ddf-947e-4154-bbd1-3dba24f1bdbd"}, "date": "2018-12-01T00:15:58.598174+00:00"}, "pull_request": {"type": "pullrequest", "id": 95, "links": {"self": {"href": "data/repositories/osrf/subt/pullrequests/95.json"}, "html": {"href": "#!/osrf/subt/pull-requests/95"}}, "title": "Communication model based on graph cost"}}, {"update": {"description": "**Motivation**: Before this pull request, one of the parameters of the communication model is distance between source and destination. For SubT, distance is not very appropriate because source and destination could be very close but with a thick wall in between. Similarly, source and destination could be far but within line of sight across a straight section of a tunnel. This pull request introduces a new replacement for distance: connectivity cost.\r\n\r\n**Changes to world files**: After this pull request, a SubT world requires three different files:\r\n\r\n* <SCENARIO>.world: The regular Gazebo world file. Nothing changes here.\r\n* <SCENARIO>.dot: This text file captures the topological map of the scenario. Each section of the scenario \\(e.g.: a tunnel tile, the staging area\\) is a vertex of a graph and all pairs of sections physically connected in the world are connected with an edge in the graph. Additionally, vertices capture the model type and model name in case is relevant for the future.\r\n* <SCENARIO>.dat: This binary file is a look-up-table used by the communication model. The content of this file is a sequence of tuples with the format `<int32_t, int32_t, int32_t, uint64_t>`. The first three elements represent a 3D point and the last element is the Id of the vertex associated to the model that surrounds the previous point.\r\n\r\n**Changes to the communication model:** After this pull request, the communication model loads the `.dat` and `.dot` files associated to the current Gazebo world. The `.dot` file is used to create an in-memory graph. We run `Dijkstra` on this graph to get the cost of traversing any pair of vertices. The `.dat` file is used to convert a 3D point to the vertex Id where the point is located. This will be relevant when we have two robots located in two 3D coordinates of the world. We need to know which vertices correspond to those two points. When we have the two vertex Ids, we can use the information that we got after running `Dijkstra` to get the associated cost of the path connecting the two robots. The SubT message is discarded if the cost is higher than a given threshold. This threshold is a new parameter of the communication model named `comms_cost_max`.\r\n\r\n**How are the costs being assigned to each edge in the graph?** Manually and based on the next heuristic:\r\n\r\n* Straight section <-> straight section:`1`\r\n* Straight section <-> non-straight section:`3`\r\n* Non-straight section <-> non-straight section:`6`\r\n\r\n**How do I \\[re\\]generate a** `.dat` **file?** Let's use an example for generating `tunnel_practice_1.dat`:\r\n\r\n    roslaunch subt_gazebo visibility.launch scenario:=tunnel_practice_1\r\n\r\nYou don't need to do this step unless you create a custom world file or modify an existing one because we are committing the `.dat` files.\r\n\r\n**Why are we committing the .dat \\(binary\\) files into the repository?** We considered a couple of options, here\u2019s one:\r\n\r\n* Launch the visibility.launch file when running the regular quickstart.launch . This was a promising idea but launch files are not enough to implement the logic that we want. We want to launch the visibility.launch first, and then, when the `.dat` file has been generated launch the quickstart.launch . We might use scripts instead, but given the different set of launch files that we have, it will complicate things unnecessary. The solution of checking in these `.dat` files is very simple \\(although I agree that not super elegant\\).\r\n\r\n**Developer bonus:** I wouldn\u2019t officially advertise it but there\u2019s a service available \\(only if you\u2019re in the same machine as Gazebo\\)  to display all the areas of the world that are visible from the perspective of one robot. It uses Gazebo markers but it slows down gzclient a lot given the amount of markers published. You can type the following command from the console:\r\n\r\n    ign service -s /subt/comms_model/visualize --reqtype ignition.msgs.StringMsg --reptype ignition.msgs.Boolean  --timeout 60000 --req 'data: \"X1\"'\r\n\r\nFeel free to replace `X1` with the name of the robot you want to check.", "title": "Communication model based on graph cost", "destination": {"commit": {"hash": "ac3cd9a6a065", "type": "commit", "links": {"self": {"href": "data/repositories/osrf/subt/commit/ac3cd9a6a065.json"}, "html": {"href": "#!/osrf/subt/commits/ac3cd9a6a065"}}}, "repository": {"links": {"self": {"href": "data/repositories/osrf/subt.json"}, "html": {"href": "#!/osrf/subt"}, "avatar": {"href": "data/bytebucket.org/ravatar/{3c95f6ad-c304-407c-b838-09597d836552}ts=2272898"}}, "type": "repository", "name": "subt", "full_name": "osrf/subt", "uuid": "{3c95f6ad-c304-407c-b838-09597d836552}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "698037271ce6", "type": "commit", "links": {"self": {"href": "data/repositories/osrf/subt/commit/698037271ce6.json"}, "html": {"href": "#!/osrf/subt/commits/698037271ce6"}}}, "repository": {"links": {"self": {"href": "data/repositories/osrf/subt.json"}, "html": {"href": "#!/osrf/subt"}, "avatar": {"href": "data/bytebucket.org/ravatar/{3c95f6ad-c304-407c-b838-09597d836552}ts=2272898"}}, "type": "repository", "name": "subt", "full_name": "osrf/subt", "uuid": "{3c95f6ad-c304-407c-b838-09597d836552}"}, "branch": {"name": "visibility_lut"}}, "state": "OPEN", "author": {"display_name": "Carlos Ag\u00fcero", "uuid": "{da8a8e89-4bb0-421b-bd0e-dbbed3d4ed6a}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bda8a8e89-4bb0-421b-bd0e-dbbed3d4ed6a%7D"}, "html": {"href": "https://bitbucket.org/%7Bda8a8e89-4bb0-421b-bd0e-dbbed3d4ed6a%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/692bf15758111acaddae4da15a47f9e5d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCA-0.png"}}, "nickname": "caguero", "type": "user", "account_id": "557058:4ded1ddf-947e-4154-bbd1-3dba24f1bdbd"}, "date": "2018-12-01T00:15:30.802460+00:00"}, "pull_request": {"type": "pullrequest", "id": 95, "links": {"self": {"href": "data/repositories/osrf/subt/pullrequests/95.json"}, "html": {"href": "#!/osrf/subt/pull-requests/95"}}, "title": "Communication model based on graph cost"}}, {"update": {"description": "**Motivation**: Before this pull request, one of the parameters of the communication model is distance between source and destination. For SubT, distance is not very appropriate because source and destination could be very close but with a thick wall in between. Similarly, source and destination could be far but within line of sight across a straight section of a tunnel. This pull request introduces a new replacement for distance: connectivity cost.\r\n\r\n**Changes to world files**: After this pull request, a SubT world requires three different files:\r\n\r\n* <SCENARIO>.world: The regular Gazebo world file. Nothing changes here.\r\n* <SCENARIO>.dot: This text file captures the topological map of the scenario. Each section of the scenario \\(e.g.: a tunnel tile, the staging area\\) is a vertex of a graph and all pairs of sections physically connected in the world are connected with an edge in the graph. Additionally, vertices capture the model type and model name in case is relevant for the future.\r\n* <SCENARIO>.dat: This binary file is a look-up-table used by the communication model. The content of this file is a sequence of tuples with the format `<int32_t, int32_t, int32_t, uint64_t>`. The first three elements represent a 3D point and the last element is the Id of the vertex associated to the model that surrounds the previous point.\r\n\r\n**Changes to the communication model:** After this pull request, the communication model loads the `.dat` and `.dot` files associated to the current Gazebo world. The `.dot` file is used to create an in-memory graph. We run `Dijkstra` on this graph to get the cost of traversing any pair of vertices. The `.dat` file is used to convert a 3D point to the vertex Id where the point is located. This will be relevant when we have two robots located in two 3D coordinates of the world. We need to know which vertices correspond to those two points. When we have the two vertex Ids, we can use the information that we got after running `Dijkstra` to get the associated cost of the path connecting the two robots. The SubT message is discarded if the cost is higher than a given threshold. This threshold is a new parameter of the communication model named `comms_cost_max`.\r\n\r\n**How are the costs being assigned to each edge in the graph?** Manually and based on the next heuristic:\r\n\r\n* Straight section <-> straight section:`1`\r\n* Straight section <-> non-straight section:`3`\r\n* Non-straight section <-> non-straight section:`6`\r\n\r\n**How do I \\[re\\]generate a** `.dat` **file?** Let's use an example for generating `tunnel_practice_1.dat`:\r\n\r\n    roslaunch subt_gazebo visibility.launch scenario:=tunnel_practice_1\r\n\r\nYou don't need to do this step unless you create a custom world file or modify an existing one because we are committing the `.dat` files.\r\n\r\n**Why are we committing the .dat \\(binary\\) files into the repository?** We considered a couple of options, here\u2019s one:\r\n\r\n* Launch the visibility.launch file when running the regular quickstart.launch . This was a promising idea but launch files are not enough to implement the logic that we want. We want to launch the visibility.launch first, and then, when the `.dat` file has been generated launch the quickstart.launch . We might use scripts instead, but given the different set of launch files that we have, it will complicate things unnecessary. The solution of checking in these `.dat` files is very simple \\(although I agree that not super elegant\\).\r\n\r\n**Developer bonus:** I wouldn\u2019t officially advertise it but there\u2019s a service available \\(only if you\u2019re in the same machine as Gazebo\\)  to display all the areas of the world that are visible from the perspective of one robot. It uses Gazebo markers but it slows down gzclient a lot given the amount of markers published. You can type the following command from the console:\r\n\r\n    ign service -s /subt/comms_model/visualize --reqtype ignition.msgs.StringMsg --reptype ignition.msgs.Boolean  --timeout 60000 --req 'data: \"X1\"'\r\n\r\nFeel free to replace `X1` with the name of the robot you want to check.", "title": "Communication model based on graph cost", "destination": {"commit": {"hash": "ac3cd9a6a065", "type": "commit", "links": {"self": {"href": "data/repositories/osrf/subt/commit/ac3cd9a6a065.json"}, "html": {"href": "#!/osrf/subt/commits/ac3cd9a6a065"}}}, "repository": {"links": {"self": {"href": "data/repositories/osrf/subt.json"}, "html": {"href": "#!/osrf/subt"}, "avatar": {"href": "data/bytebucket.org/ravatar/{3c95f6ad-c304-407c-b838-09597d836552}ts=2272898"}}, "type": "repository", "name": "subt", "full_name": "osrf/subt", "uuid": "{3c95f6ad-c304-407c-b838-09597d836552}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "698037271ce6", "type": "commit", "links": {"self": {"href": "data/repositories/osrf/subt/commit/698037271ce6.json"}, "html": {"href": "#!/osrf/subt/commits/698037271ce6"}}}, "repository": {"links": {"self": {"href": "data/repositories/osrf/subt.json"}, "html": {"href": "#!/osrf/subt"}, "avatar": {"href": "data/bytebucket.org/ravatar/{3c95f6ad-c304-407c-b838-09597d836552}ts=2272898"}}, "type": "repository", "name": "subt", "full_name": "osrf/subt", "uuid": "{3c95f6ad-c304-407c-b838-09597d836552}"}, "branch": {"name": "visibility_lut"}}, "state": "OPEN", "author": {"display_name": "Carlos Ag\u00fcero", "uuid": "{da8a8e89-4bb0-421b-bd0e-dbbed3d4ed6a}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bda8a8e89-4bb0-421b-bd0e-dbbed3d4ed6a%7D"}, "html": {"href": "https://bitbucket.org/%7Bda8a8e89-4bb0-421b-bd0e-dbbed3d4ed6a%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/692bf15758111acaddae4da15a47f9e5d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCA-0.png"}}, "nickname": "caguero", "type": "user", "account_id": "557058:4ded1ddf-947e-4154-bbd1-3dba24f1bdbd"}, "date": "2018-12-01T00:15:30.767474+00:00"}, "pull_request": {"type": "pullrequest", "id": 95, "links": {"self": {"href": "data/repositories/osrf/subt/pullrequests/95.json"}, "html": {"href": "#!/osrf/subt/pull-requests/95"}}, "title": "Communication model based on graph cost"}}]}